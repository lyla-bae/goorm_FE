<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Intersection Observer Example</title>
  <style>
    .post {
      margin: 20px;
      padding: 20px;
      border: 1px solid #ccc;
      border-radius: 5px;
      transition: opacity 0.5s ease;
    }
    .hidden {
      opacity: 0;
    }
  </style>
</head>
<body>
  <div id="post-container"></div>
  <script>
    // 데이터를 저장할 배열
    let posts = [];
    // 현재 페이지를 추적하는 변수
    let currentPage = 1;
    // 한 페이지에 보여줄 데이터 수
    const postsPerPage = 10;

    // JSONPlaceholder에서 데이터를 가져오는 함수
    async function fetchPosts() {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts');
      posts = await response.json();
      displayPosts();
    }

    // 데이터를 화면에 보여주는 함수
    function displayPosts() {
      const container = document.getElementById('post-container');
      const start = (currentPage - 1) * postsPerPage;
      const end = currentPage * postsPerPage;
      
      // ✅ currentPosts 변수에 한 페이지에 보여줄 만큼 데이터를 잘라 복사해줍니다
      const currentPosts = posts.slice(start, end);

      
      // ✅ currentPosts 배열로 HTML을 생성하고, container 끝에 붙여줍니다
      // div를 생성해주시고, 그 안에 <h2>${post.id}. ${post.title}</h2><p>${post.body}</p> 를 넣어주세요
      // 또한, 생성한 div에 post, hidden 두 개의 클래스를 붙여주세요
      currentPosts.forEach(post => {
            const postDiv = document.createElement('div');
            postDiv.classList.add('post', 'hidden');
            postDiv.innerHTML = `<h2>${post.id}. ${post.title}</h2><p>${post.body}</p>`;
            container.appendChild(postDiv);
            // 단, hidden 은 애니메이션을 위한 클래스명이라 100ms 뒤에 해당 클래스를 지워주세요
            setTimeout(() => {
            postDiv.classList.remove('hidden');
            }, 100);
        });
      

      // 현재 페이지를 증가시킴
      currentPage++;
      // Intersection Observer를 설정
      setObserver();
    }

    // Intersection Observer를 설정하는 함수
    function setObserver() {
      const options = {
        root: null,
        rootMargin: '0px',
        threshold: 1.0
      };

      // ✅ 여기에 intersection observer 를 활용해서 요구사항에 맞게 개발해주세요

        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
            if (entry.isIntersecting) {
                // 관찰 중지
                observer.unobserve(entry.target);

                if(currentPage <= Math.ceil(posts.length / postsPerPage)) {
                    // 마지막 포스트가 화면에 보이면 다음 페이지의 포스트를 불러옴
                    displayPosts();
                }
            }
            });
        }, options);
      

      // ✅ 마지막 포스트 요소를 관찰하여, 마지막 요소에만 observer를 적용해야 합니다
      const lastPost = document.querySelector(".post:last-child");
      if (lastPost) {
        observer.observe(lastPost);
      }

      
    }

    // 페이지 로드 시 데이터를 가져옴
    fetchPosts();
  </script>
</body>
</html></html>